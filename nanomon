#!/usr/bin/env python
#
#  Extremely small and light weight monitoring.
#
#  Copyright (c) 2011, Sean Reifschneider <jafo@tummy.com>, All Rights Reserved
#  Licensed under GPL version 3 or later, see "LICENSE" for more information.

configFile = '/usr/local/etc/nanomon.conf'

import os
import sys
import syslog
syslog.openlog('nanomon', syslog.LOG_PID)


###############################
def loadConfigFile(configFile):
	class configClass:
		def __init__(self):
			self.commands = []
			self.debug = 0
			self.statusfile = None
			self.mailto = None
			self.maxfailures = 15
			self.mailcmd = '/usr/sbin/sendmail -t -oi'

		def cmd_command(self, command, success, description = None):
			self.commands.append(( command, success, description ))

		def cmd_statusfile(self, statusfile):
			self.statusfile = statusfile

		def cmd_mailto(self, mailto):
			self.mailto = mailto

		def cmd_mailcmd(self, mailcmd):
			self.mailcmd = mailcmd

		def cmd_debug(self, level = 1):
			self.debug = level

	#  set up config environment
	config = configClass()
	namespace = {
			'command' : config.cmd_command,
			'mailto' : config.cmd_mailto,
			'statusfile' : config.cmd_statusfile,
			'debug' : config.cmd_debug,
			'mailcmd' : config.cmd_mailcmd,
			}

	#  load the file
	import re
	try:
		execfile(configFile, {'re' : re}, namespace)
	except Exception:
		print 'ERROR: Loading configuration file failed.  See below for details:'
		raise
	
	#  return the data
	return(config)


########################
def runcommands(config):
	import shlex, subprocess

	failures = []
	descriptions = []
	any_failed = False
	for command, success, description in config.commands:
		if isinstance(command, str):
			args = shlex.split(command)
		else:
			args = command

		if description == None:
			description = os.path.basename(args[0])

		proc = subprocess.Popen(args, stdout = subprocess.PIPE,
				stderr = subprocess.PIPE, close_fds = True)
		output, errors = proc.communicate()

		if isinstance(success, int):
			#print 'int', proc.returncode, success
			if proc.returncode != success:
				descriptions.append(description)
				failures.append('Check "%s"' % command)
				failures.append('Exit=%s expected %s'
						% ( proc.returncode, success ))
				failures.append('   Output: %s' % output)
				failures.append('   Stderr: %s' % errors)
				any_failed = True
		elif callable(success):
			#print 'func', success(output)
			ret = success(output)
			if not ret:
				descriptions.append(description)
				failures.append('Check "%s"' % command)
				failures.append('Function returned "%s"' % ( repr(ret), ))
				failures.append('   Output: %s' % format(output))
				failures.append('   Stderr: %s' % format(errors))
				any_failed = True
		else:
			#print 'in', success, output
			if success not in output:
				descriptions.append(description)
				failures.append('Check "%s"' % command)
				failures.append('String "%s" not found in output' % ( success, ))
				failures.append('   Output: %s' % format(output))
				failures.append('   Stderr: %s' % format(errors))
				any_failed = True

	config.any_failed = any_failed
	config.failures = failures
	config.descriptions = descriptions

	return any_failed


#######################
def loadstatus(config):
	import pickle
	default = {
				'failures' : 0,
				'isup' : 1,
				'descriptions' : None,
				}

	try:
		fp = open(config.statusfile, 'r')
		filedata = fp.read()
		fp.close()

		try:
			data = pickle.loads(filedata)
		except:
			return default
		return data
	except IOError:
		return default


###############################
def savestatus(config, status):
	import pickle, os
	fp = open(config.statusfile + '.tmp', 'w')
	pickle.dump(status, fp)
	fp.close()
	os.rename(config.statusfile + '.tmp', config.statusfile)


##############
def format(s):
	if s == None: return s
	return s.rstrip()


###########################
def sendmail(config, isup):
	import subprocess, os

	hostname = os.uname()[1]

	proc = subprocess.Popen(['/usr/sbin/sendmail', '-t', '-oi'],
			stdin = subprocess.PIPE, close_fds = True)
	proc.stdin.write('From: %s\n' % config.mailto)
	proc.stdin.write('To: %s\n' % config.mailto)
	if isup:
		proc.stdin.write('Subject: UP: Service restored\n\n')
		proc.stdin.write('\n')
		proc.stdin.write('Services are restored on %s\n' % hostname)
	else:
		descriptions = ', '.join(config.descriptions)
		proc.stdin.write('Subject: DOWN: Service OUTAGE: %s\n\n' % descriptions)
		proc.stdin.write('\n')
		proc.stdin.write('Services have issues on %s\n' % hostname)
		proc.stdin.write('\n')
		for line in config.failures:
			proc.stdin.write('%s\n' % line)
	proc.stdin.close()
	proc.wait()


#############################
def loadconfig(configFile):
	'''A wrapper for loading the config file which displays errors.'''
	try:
		config = loadConfigFile(configFile)
	except IOError, e:
		if e.errno == 2:
			print 'ERROR: Unable to open config file "%s":' % configFile
			print '  ', str(e)
			syslog.syslog('Invalid config file "%s"' % configFile)
			sys.exit(1)
		raise

	return config


###########
def main():
	config = loadconfig(configFile)

	if not config.mailto:
		print 'ERROR: No "mailto" specified in config file'
		sys.exit(1)

	old_status = loadstatus(config)
	runcommands(config)

	if config.any_failed:
		old_status['failures'] += 1
		old_status['descriptions'] = ', '.join(config.descriptions)
	else:
		old_status['failures'] = 0
		old_status['descriptions'] = None
	alerting = old_status['failures'] > config.maxfailures

	send_alert = False
	if old_status['isup'] and alerting:
		#  was up, now is down
		old_status['isup'] = 0
		send_alert = True
	elif not old_status['isup'] and not alerting:
		#  was down, now is up
		old_status['isup'] = 1
		send_alert = True
	
	savestatus(config, old_status)

	if send_alert:
		sendmail(config, old_status['isup'])


#############
def status():
	config = loadconfig(configFile)
	old_status = loadstatus(config)
	if old_status['failures'] < 1:
		print 'OK'
		sys.exit(0)

	old_status['status'] = 'DOWN'
	if old_status['isup']:
		old_status['status'] = 'UP'

	print ('ERROR: %(failures)s failures (%(descriptions)s), %(status)s'
			% old_status)
	sys.exit(1)


############
def reset():
	config = loadconfig(configFile)
	old_status = loadstatus(config)
	old_status['isup'] = 1
	old_status['failures'] = 0
	old_status['descriptions'] = None
	savestatus(config, old_status)


############################
if __name__ == '__main__':
	from optparse import OptionParser

	opt_description = ('A small service checking program, which can run an '
			'series of commands, check their results, and report when they '
			'repeatedly fail, and when they recover.')
	opt_epilog = ('If called with the "reset" command, the status '
			'of all services is reset to to the default state.  If called '
			'with the "status" command, the state file is loaded and either '
			'"OK" is printed and nanomon exits with 0, or information on the '
			'failed services is printed and nanomon exits with 1.  If called '
			'with no command-line commands, a check of all services is run.  '
			'Typically this is how it is called from cron.')

	parser = OptionParser(usage='%prog [options] [status|reset]',
			description=opt_description, epilog=opt_epilog)
	parser.add_option('-c', '--config', dest='config_file',
			metavar='FILE', help='Override the configuration file path')
	(options, args) = parser.parse_args()

	if options.config_file:
		configFile = options.config_file

	if 'status' in args:
		status()
	elif 'reset' in args:
		reset()
	else:
		main()
